# MultiBaseballGame
 
## 개요

이 프로젝트는 언리얼 엔진을 사용하여 구현된 숫자 야구 게임(Bulls and Cows)입니다. 두 플레이어가 서로 다른 3자리 숫자를 맞추는 방식으로 진행됩니다.

## 게임 규칙

플레이어는 서로 겹치지 않는 3자리 숫자(예: /123, /357)를 서버에 제출합니다.

두 플레이어 중 한 명이라도 3번 안에 정답(3S, 즉 3개의 숫자와 위치가 정확히 맞음)을 맞추면 해당 플레이어의 스코어가 1점 증가합니다.

3번의 기회 내에 둘 다 정답을 맞추지 못하면 무승부(Draw) 처리됩니다.

잘못된 입력의 경우 반칙패 처리됩니다.
- 중복된 숫자가 포함된 경우 (예: /112, /344)
- / 기호를 포함하지 않은 경우 (예: 123, 357)
- 3자리가 아닌 숫자를 입력한 경우 (예: /12, /1234)

## 프로젝트 구조

- UBaseballManagerFunctionLibrary

게임의 3가지 생성 로직 및 검사 로직을 담당합니다.

숫자 생성 방식:

TArray 10개의 Index를 생성하여 1~3까지의 Index에 숫자를 배치한 후 Swap 방식으로 섞습니다.

Index는 숫자를 나타내고, 내부 Element는 해당 숫자의 위치를 나타냅니다.

예: 답이 357인 경우 TArray[3] = 1, TArray[5] = 3, TArray[7] = 3이 되며, 나머지는 0을 가집니다.

숫자 입력 시, TArray 값을 확인하여 Strike와 Ball 여부를 빠르게 판별합니다.

- GameMode

게임의 전체적인 진행을 관리합니다.

- GameState

모든 클라이언트와 서버가 공용으로 관리하는 자원을 처리합니다.

주요 관리 요소:

라운드 시간

현재 플레이어 닉네임 (Index)

입력 결과 (입력자, 2S 1B 등의 결과)

- PlayerState

개별 플레이어(클라이언트)가 관리하는 자원을 처리합니다.

주요 관리 요소:

플레이어의 승리 횟수

현재 라운드의 남은 입력 횟수

플레이어 닉네임

- PlayerController

서버와 클라이언트 간의 입력 등을 중개하는 역할을 합니다.

- BaseBallTimerManager

시간을 관리하는 객체입니다.

초 단위로 시간을 전송하는 것이 아닌, 일정 시간마다 동기화를 수행하여 최적화된 시간 관리를 합니다.

## 개발 과정에서의 고려 사항

이번 프로젝트에서는 각 요소를 어디서 관리해야 하는지를 신중하게 고민했습니다.

처음에는 Baseball의 정답을 FunctionLibrary(전역)에서 관리하는 것이 아니라 UObject를 상속받은 객체에서 관리하려 했으나, 적절한 위치를 찾는 과정이 필요했습니다.

Baseball의 정답을 가진 객체에서 정답 생성과 검사를 수행하도록 했는데, 처음에는 게임의 전체적인 흐름을 관리하는 GameMode에서 가져야 하는지 고민했습니다.

그러나, Baseball의 정답은 게임의 전체적인 상태를 가지는 GameState에서 관리하는 것이 맞는지에 대한 고민이 있었습니다.

최종적으로, 플레이어가 필요한 게임의 정보는 정답 자체가 아닌 입력에 대한 결과라는 점을 인지하고 이를 수정했습니다.

따라서, 서버와 클라이언트 간에 주고받는 정보는 **정답이 아니라, 입력에 따른 결과(스트라이크, 볼 정보)**를 전송하도록 변경했습니다.

## 추가 구현 사항: 시간 동기화

서버에서 0.1초마다 시간을 전송하는 방식은 부하가 클 것으로 예상되었고, 서버와 클라이언트의 시간이 크게 다르지 않다는 점을 고려하여 동기화 방식을 도입했습니다.
시간 5.0초마다 반복해서 동기화를하며 동기화작업이 잘되는지는 보기위해 시작부분에는 동기화가 들어가지않습니다.
- 시간 동기화 방식

서버가 시간을 지속적으로 전송하는 대신, 시간이 시작하는 부분을 맞추는 방식을 채택했습니다.

하지만, 서버에서 보낸 시간이 클라이언트에 도달하는 데 지연이 발생할 수 있으므로, 두 컴퓨터의 시간을 최대한 근사하게 동기화하는 방법을 고민했습니다.

- 동기화 프로세스

서버에서 현재 시간을 ServerTime0 (ST0)과 함께 클라이언트로 전송합니다.

클라이언트는 이를 수신하고, **자신의 현재 시간 ClientTime0 (CT0)**과 함께 다시 서버로 전송합니다.

서버는 이를 수신하고, **수신 당시의 서버 시간 ServerTime1 (ST1)**을 다시 클라이언트로 보냅니다.

결과적으로, 서버와 클라이언트는 다음 네 개의 시간을 가지게 됩니다:

ServerTime0 (ST0)

ClientTime0 (CT0)

ClientTime1 (CT1)

ServerTime1 (ST1)

이를 바탕으로 클라이언트는 다음 식을 사용하여 시간 차이를 계산합니다:

P0 + P1 = ST1 - ST0

P1 + P2 = CT1 - CT0

클라이언트의 시간 도착 기준은 P0 + P1 + P2이므로, 이를 최소화하는 방식으로 보정합니다.

- 보정 방식

정확한 시간 일치는 어렵지만, 최소한의 오차로 보정하는 방법을 사용했습니다.

P0 + 2 * P1 + P2 값을 최소화하는 시점을 기준으로 동기화합니다.

다만, P1 값이 작은 경우에도 P0 + P2가 작다면 오차가 발생할 수 있습니다.

하지만 2 * P1이 적용되었기 때문에, 기존 P1보다 크더라도 전체적인 오차가 최소가 되는 값을 찾을 가능성이 높습니다.
